
C++11 new library feature  

1, std::begin/std::end

- std::begin and std:end free functions were added to return begin and end iterators of a container generically.

- These functions als work with raw arrays which do not have begin and end member functions.

template<typename T>
int CountTwos(const T& container) {
    return std::count_if(std::begin(container),std::end(container),[](int item) {
	return item == 2;
	});
}

std::vector<int> vec= {2,2,43,435};
int arr[8] = {2,43,45};

auto a = countTwos(vec);
auto b = countTwos(arr);

*****************************************************************************************************************

2, std::async

- std::async runs the given function either asynchoronously or lazily-evaluated, then returns a std::future which 
  holds the result of that function call.
  
- The first parameter is the policy which can begin

  1, std::launch::async || std::launch::deferred it is up to the implemenation whetther to perform asynchronous exeuction or lazy evalution.
  2, std::launch::async - Run the callable object on the new thread.
  3, std::launch::deferred - Perform lazy evaluation on the current thread.
  
int foo() {
/** Do something here, then return the result */
return 100;
}

auto handle = std::async(std::launch::async,foo); // create an async task
auto result = hangle.get(); // wait for the result.


****************************************************************************************************************

3, Memory model :

- C++ 11 introduces a memory model for C++, which means library support for threading and atomic operations. 
- Some of these operations include atomic loads/stores, compare and swap , atomic flags, promises, futures, locks and condition variables.

***************************************************************************************************************


4, std::ref :

- std::ref(val) is used to create object of type std::reference_wrapper that holds reference of val.

- Used in cases when usual reference passing using & does not compile or & is dropped due to type deduction.

-  std:cref is similar but created reference wrapper holds the const reference to val.

// create a constainer to store reference of objects.
  auto val = 99;
  auto _ref = std::ref(val);
  _ref++;
  auto _cref = std::cref(val);
  // _cref++ does not compile
  std::vector<std::reference_wrapper<int>> vec;  // vector<int&> does not compile
  vec.push_back(_ref); // vec.push_back(&i) does not compile
  cout << vec << endl;  // prints 100
  cout << vec[0] << endl; // prints 100
  cout << _cref; // prints 100
  
*****************************************************************************************************************************

5, make_shared 

- std::make_shared is the recommand way to create instances of std::shared_ptr s due to the following reasons: 

(01) Avoid having to use the new operator.
(02) Prevents code repetition when specifying the underlying type the pointer shall hold.
(03) It provides exeception safety. suppose we were calling a funcion fool like so:

 foo(std::shared_ptr<T>{new T{}}, function_that_throws(), std::shared_ptr<T>{ new T{}}); 
 
The compiler is free to call new T{}, then function_that_throws(), and so on ... Since we have allocated data on the heap
in the first construction of a T, we have introduced a leak here. 

With std::make_shared, we are given exception-safety:

foo(std::make_shared<T>(), function_that_throws(),std::make_shared<T>());

- Prevents haveing to do two allocation.when calling std::shared_ptr{ new T{} }, we have to allocate memory for T, then
  in the shared_pointer we have to allocate memory for the control block within the pointer.

- See the section on smart_pointer for more information on std::unique_ptr and std::shared_ptr.


***************************************************************************************************************************

6, unoredered containers

- These containers maintain average constant-time complexity for search,insert, and remove operations.
- In order to achieve constant-time complexity, sacrifices order for speed by hashing elements into buckets.
- There are four unordered containers:

1, unordered_set
2, unordered_multiset
3, unordered_map
4, unordered_multimap

*****************************************************************************************************************************

7, std::array

- std::array is a container build on top of a C-style array.
- Supports common container operations such as sorting.

std::array<int,3> a = {2,1,3};
std::sort(a.begin(),a.end());  // a == { 1,2,3 }
for(int &x : a) x *= 2;   // a == { 2, 4, 6}


***************************************************************************************************************************

8, tie :

- Creates a tuple of lvalue references.
- Useful for unpacking std::pair and std::tuple objects.
- Use std::ignore as a placeholder for ignored values.
- In C++ 17, structure bindings should be used instead.

// With tuples...
std::string playerName;
std::tie(std::ignore, playerName,std::ignore)=std::make_tuple(91,"John Travares","NYI");

// with pairs
std::string yes,no;
std::tie(yes,no) = std::make_pair("yes","no");


*****************************************************************************************************************************

9. tuples

- Tuples are a fixed-size collection of heterogenous values.
- Access the elements of a std:::tuple by unpacking using std::tie or using std::get

// 'playerProfile' has type "std::tuple<int, const char *,const char *>'.
auto playerProfile = std::make_tuple(51,"Frans Nielsen","NYI");
std::get<0>playerProfile; // 51
std::get<1>playerProfile); // 'Frans Nielsen"
std::get<2>(playerProfile));  "NYI"

**************************************************************************************************************************


10, std::chrono

- The chrono library contains a set of utility functions and types that deal with durations, clocks, and time points.
- One use case of this library is benchmarking code:

  std::chrono::time_point<std::chrono::steady_clock> start, end;
  start=std::chrono::steady_clock::now();
  //  Some computations
  end = std::chrono::steady_clock::now();
  std::chrono::duration<double> elapsed_seconds = end-start;
  double t = elapsed_seconds.count(); // t number of seconds, represente as a 'double'
  
*************************************************************************************************************************

11, smart_pointer

- C++ introduces new smart pointer: std::unique_ptr,std::shared_ptr,std::weak_ptr,std::auto_ptr now becomes
  depreciated and then eventually removed in C++ 17.
  
- std::unique_ptr is a non-copyable, movable pointer that manages its own heap-allocated memory. 
  Note: Prefer using the std::make_x helper function as opposed to using constructors.
 
- std::unique_ptr<Foo> p1 { new Foo{} }; // 'p1' owns 'Foo'
  if(p1) {
	p1->bar();
  }
  std::unique_ptr<Foo> p2 {std::move(p1)}; // Now 'p2' owns 'Foo'
  f(*p2);
  
  p1 = std::move(p2);  // Ownership returns to 'p1' -- 'p2' gets destroyed
  }
  if(p1) {
  p1->bar();
  }
  
  //'Foo' instance is destroyed when 'p1' goes out of scope.
  
- A std::shared_ptr is a smart pointer that manages a resource that is shared across multiple owners.
- A shared pointer holds a control block which has a few components such as the managed object and a reference counter.
- All control block access is thread-safe, however, manipulating the managed object itself is not thread-safe.

void foo(shared_ptr<T> t) {
// Do something with 't' ...
}  
 
void bar(std::shared_ptr<T> t) {
// Do something with 't'...
}

void baz(std::shared_ptr<T> t) {
// Do something with 't'...
}

std::shared_ptr<T> p1{new T{}}
// Perhaps these take place in another threads 

****************************************************************************************************************************

(12) Type traits

- Type traits define a compile-time template based interface to query or modify the properties of types.

static_assert(std::is_integral<int>::value);
static_assert(std::is_same<int,int>::value);
static_assert(std::is_same::conditional<true, int, double>::type, int>::value);

***************************************************************************************************************************

(13) std::to_string

- Converts a numeric argument to a std::string.

  std::to_string(1.2);  // == "1.2"
  std::to_string(123);   // == "123"
  
**************************************************************************************************************************

(14) std::thread

- The std::thread library provides a standard way to control threads,such as spawning and killing them.
- In the example below, multiple threads are spawned to do differnt calculations and the program waits for all of them to finish.

void foo(bool clause) { /* do something ...*/ }
std::vector<std::thread> threadVector;
threadsVectors.emplace_back([](){
// lambda function that will be invoked
});
threadsVector.emplace_back(foo, true); // thread wll run foo(true)
for(auto& thread : threadsVector)
{
thread.join(); // wait for threads to finish 
}

***************************************************************************************************************************

(15) std::forward

- Return the arguments passed to it while maintaining their value category and cv-qualifers. 
- useful for generic code and factories.
- Used in conjunction with forwarding references.
- A definition of std::forward:

	template<typename T>
	T&& forward(typename remove_reference<T>::type& arg) {
		return static_cast<T&&>(arg); 
	}
	
- An example of a function wrapper which just forwards other A objects to a new A object's copy or move constructor.

  struct A {
    A() = default;
	A(const A&o) { std::cout << "copied" << std::endl; }
	A(A&& o) { std::cout << "moved" << std::endl; }
  };
  
  template<typename T>
  A wrapper(T&& arg) {
	return A{std::forward<T>(arg);
  }
  
  wrapper(A{});  // moved
  A a;
  wrapper(a); // copied
  wrapper(std::move(a)); // moved 
  
****************************************************************************************************************************

(16) move

- move indicates that the object passed to it may have its resources transferred.
- Using objects that have been moved from should be used with care, as they can be left in an unspecified state.

- A definition of std::move ( performing a move is nothing more than casting to an rvalue reference).

  template<typename T>
  typename remove_reference<T>::type&& move(T&& arg) {
	return static_cast<typename remove_reference<T>::type&&>(arg);
  }
  
  Transferring std::unique_ptr S:
  
  std::unique_ptr<int> p1 {new int{0}}; // in practice, use std::make_unique
  std::unique_ptr<int> p2 = p1;  // error -- cannot copy unique pointers
  std::unique_ptr<int> p3 = std::move(p1);  // move 'p1' into 'p3' // now unsafe to dereference object held by 'p1'
  
****************************************************************************************************************************  

*****************************************************************************************************************************
*****************************************************************************************************************************

								C++ 11 new language feature
								
****************************************************************************************************************************
****************************************************************************************************************************
					

1, Raw string literals

- C++ 11 introduces a new way to declare string literals as "raw string literals".

- Characters issued from an escape sequence (tabs, line feeds, single backslashes, etc)
  can be inputted raw while preserving formatting.
  
- This is useful, for example, to write literary text, which might contain a lot of quotes or special formatting.

- This can make your string literals easier to read and maintain.

- A raw string literal is declared using the following syntax:

  R"delimiter(raw_characters)delimiter"
  
  where
  
  1, delimiter is an optional sequence of characters made of any source character except parentheses,backslahes and spaces.
  2, raw_characters is any raw character sequence; must not contain the closing sequence ")delimiter".
  
  Example:
  
  // msg1 and msg2 are equivalent.
  const char* msg1 = "\nHello, \n\tworld!\n";
  const char* msg2 = R("
  Hello,
		 world!
  )";
  
  
*******************************************************************************************************************************

2, char32_t and char16_t

- Provides standard types for representing UTF-8 strings.

  char32_t utf8_str[] = U"\u0123";
  char16_t utf8_str[] = u"\u0123"; 
  
  
******************************************************************************************************************************

3, Noexcept specifier

- The noexcept specifier specifies whether a function could throw exeptions.
- It is an improved version of throw().

  void fun1() noexcept;  // does not throw
  void fun2() noexcept(true); // does not throw
  void fun3() throw(); // does not throw
  
  void fun4() noexcept(false);  // may throw
  
- Non-throwing functions are permiteed to call potentially-throwing functions.
- Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called.

  extern void f();  // potentially-throwing
  void g() noexcept {
	f();  / valid,even if f throws
	throw 32; // valid, effectively a call a std::terminate
  }
  
*******************************************************************************************************************************
  
 4, Trailing return types:
 
 - C++ 11 allows functions and lamdbas an alternative syntax for specifying their return types.
 
  int f() {
	return 123;
  }
  vs
  auto f() -> int {
	return 123;
  }
  
  auto g = []()-> int {
	return 123;
  }
  
- This feature is especially useful when certian return types cannot be resolved.

  // NOTE: This does not compile!
  template<typename T,typename U>
  decltype(a+b) add(T a,T b) {
	return a+b;
  }
  
  // Trailing return types allows this:
  template<typename T,typename U>
  auto add(T a,T b)->decltype(a+b) {
	return a+b;
  }
  
******************************************************************************************************************************

5, Ref-qualified member functions

- Member functions can now be qualified depending on whether *this is an lvalue or rvalue reference.

- 
    struct Bar {
	...
	};
	
	struct Foo {
		Bar getBar() & { return bar; }
		Bar getBar() const& { return bar; }
		Bar getBar() && { return std::move(bar); }
	private:
		Bar bar;
	};
	
	Foo foo{};
	Bar bar = foo.getBar(); // calls 'Bar getBar() &'
	
	const Foo foo2{};
	Bar bar2 = foo2.getBar(); // calls 'Bar Foo::getBar() const&'
	
	Foo{}.getBar(); // calls 'Bar Foo::getBar() &&'
	std::move(foo).getBar();  // calls 'Bar Foo::getBar() &&'
	std::move(foo2).getBar(); // calls 'Bar Foo::getBar() const&&'
	
********************************************************************************************************************************

6, Right angle brackets

- C++ 11 is now able to infer when a series of right angle brackets is used as an operator or as a closing statement of typedef,
  without having to add whitespace.
  
 typedef std::map<int, std::map<int, std::map<int,int> > > > cpp98LongTypedef;
 typedef std::map<int, std::map<int, std::map<int,int>>>> cpp11LongTypedef; 
 
 ********************************************************************************************************************************
 
7, Non-static data member initializers:

- Allows non-static data members to be initialized where they are declared, potentially cleaning up constructors of default initializers.

// Default initialization prior to C++11
class Human {
	Human(): age{0} {}
  private:
	unsigned age;
};

// Default initialization on C++ 11
class Human {
	private:
		unsigned age{0};
};


***********************************************************************************************************************************

8, inline namespaces

- All members of an inline namespace are treated as if they were part of its parent namespace, allowing specialization of functions and easing
  the process of versioning.
- This is a transitive property, if A contains B, which in turn contains C and both B and C are inline namespaces. C's members can be used as if they were on A.
  namespace Program {
	namespace Version1 {
		int getVersion() { return 1; }
		bool isFirstVersion() { return true; }
	}
	inline namespace Version2 {
		int getVersion() { return 2;
	}
  }
  
  int version { Program::getVersion()};   // Uses getVersion() from version2
  int oldVersion { Program::Version1::getVersion()};  // Uses getVersion() from version1
  bool firstVersion { Program::isFirstVersion()};  // does not compile when Version 2 is added.
  
 ********************************************************************************************************
 
 
 9, Explicit conversion functions:
 
 - Conversion functions can now be made explicit using the explicit specifier.
 
 struct A {
	operator bool() const { return true; }
 };
 
 struct B {
	explicit operator bool() const { return true; }
 };
 
 A a;
 if(a); // OK calls A::operator bool()
 bool ba = a; // OK copy-initialization selects A::operator bool()
 
 B b;
 if(b); // OK calls A::operator boo()
 bool bb = b;  // error copy-initialization does not consider B::operator bool()
 
 ********************************************************************************************************

10, Converting construtors

- Converting constructors will convert values of braced list syntax into constructor arguments.

struct A {
	A(int) {}
	A(int,int) {}
	A(int,int,int) {}
 };
 
 A a{0,0}; // calls A::A(int,int)
 A b(0,0);  // calls A::A(int,int)
 A c = {0,0}; // calls A::A(int,int)
 A d {0,0,0}; // calls A::A(int,int,int)
 
// Note that the braced list syntax does not allow narrowing:

struct A {
A(int) {}
};

A a(1.1); // OK
A b{1.1}; // Error narrowing conversion from double to int

Note that if a constructor accepts a std::initializer_list, it will be called instead:

struct A {
	A(int) {}
	A(int,int) {}
	A(int,int,int) {}
	A(std::initializer_list<int>) {}
};

A a{0,0};  //calls A::A(std::initializer_list<int>)
A b(0,0);  //calls A::A(int,int)
A c = {0,0};  // calls A::A(std::initializer_list<int>)
A d{0,0,0}; // calls A::A(std::initializer_list<int>)


********************************************************************************************************

11, special member functions for move semantics

- The copy constructor and copy assignment operator are called when copies are made, and with C++11's2
  introduction of move semantics, there is now a move constructor and move assignment operators for moves.
  
  struct A {
	std::string s;
	A(): s{"test"} {}
	A(const A& o):s{o.s} {}
	A(A&& o) : s{std::move(o.s)}{}
	A& operator=(A&& o) {
	   s=std::move(o.s);
	   return *this;
	}
   };
   
   A f(A a) {
	return a;
  }
  
 A a1 = f(A{}} // move-constructed from rvalue temporary
 A a2 = std::move(a1); // move-constructed using std::move
 A a3 = A{};
 a2 = std::move(a3) // move-assignment using std::move
 a1 = f(A{});  // move-assignment from rvalue temporary 

*******************************************************************************************************

12, Range-based for loops

- syntatic sugar for iterating over a container's elements.

std::array<int,5> a{1,2,3,4,5};
for(int& x : a) x*=2;
// a = {2,4,6,8,10}

Note the difference between when using int as opposed to int&:

std::array<int,5> a {1,2,3,4,5};
for(int x : a) x*=2;
// a = {1,2,3,4,5}

******************************************************************************************************

13, deleted functions

- A more elegant, effieient way to provide a deleted implementation of a funciton. 
- Useful for preventing copies on objects.

class A {
	int x;
public:
	A(int x): x{x} {};
	A(const A&) = delete;
	A& operator=(const A&) = delete;
};

A x{123};
A y = x; //error -- call to deleted copy constructor
y = x;  // error -- operator= deleted


*******************************************************************************************************

14, Default functions

- A more elegant, efficient way to provide a default implementation of a function, such as a constructor.

  struct A {
	A() = default;
	A(int x) : x{x} {}
	int x {1};
  };
  A a; //a.x == 123
  A a2{123};  //a.x == 123
  
  With inheritance:
  
  struct B {
   B() : x{1} {} 
   int x;
  };
  
  struct C : B {
    //Calls B::B
	C() = default;
  }
  C c; //c.x == 1
  
********************************************************************************************************

15, Final specifier

Specifies that a virtual function cannot be overriden in a derived class or that a 
class cannot be inherited from.

struct A {
virtual void foo();
};

struct B : A {
  virtual void foo() final;
};

struct C : B {
virtual void foo();
// error -- declaration of 'foo' overrides a 'final' function 
};

Class cannot be inherited from
struct A final {};
struct B : A{}; // error -- base 'A' is marked 'final' 

*********************************************************************************************************

16, Explicit virtual overrides

- Specifies that a virtual function overrides another virtual function.
- If the virtual function does not override a parent's virtual function, throws a compiler error.

  struct A {
	virtual void foo();
	void bar();
  };
  
  struct B : A {
	void foo() override; // correct -- B::foo overrides A::foo
	void bar() override; // error -- A::bar is not virtual
	void baz() override; // error -- B::baz does not override A::baz
  };

********************************************************************************************************
********************************************************************************************************

										C++ 14 library features

********************************************************************************************************
********************************************************************************************************

1, make_unique

- std::make_unique is the recommended way to create instances of std::unique_str s due to the following reasons:

(01) Avoid having to use the new operator.
(02) Prevents code repetition when specifying the underlying type the pointer shall hold.
(03) Most importantly, it provide exception safety. Suppose we were calling a function fool like so:

  foo(std::unique_ptr<T>{new T{}), function_that_throws(), std::unique_ptr<T>{new T{}});
  
- The compiler is free to call new T{}, then function_that_throws(), and so on. Since we have allocated data on the heap
  in the first construction of a T, we have introduced a leak here.
- With std::make_unique, we are given exception-safety: 
  
  foo(std::make_unique<T>(),function_that_throws(),std::make_unique<T>());
  
- See the section on smart pointers for more information on std::unique_ptr and std::shared_ptr. 
 
************************************************************************************************************* 
 
2, Complie-time integer sequences

- The class template std::integer_sequence represents a compile time sequence of integers. 
- There are a few helpers built on top:

  (01) std:make_integer_sequence<T,N> - create a sequence of 0,...N-1 with type T.
  (02) std::index_sequence_for<T...> - converts a template parameter pack into a integer sequence
  
- Convert an array into a tuple:

	template<typename Array,std::size_t... I>
	decltype(auto) a2t_impl(const Array& a,std::integer_sequence(std::size_t, I...>) {
		return std::make_tupe(a[I]...);
	}

    template<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>
	decltype(auto) a2t(const std::array<T,N>& a) {
		return a2t_impl(a,Indices());
	}
	
*******************************************************************************************************

3, User defined literals for standard library types.

- New user-defined literals for standard library types, including new built-in literals for chrono and basic_string.

- These can be constexpr meaning they can be used at compile time.

- Some uses for these literals include compile-time integer parseing, binary literals and imaginary number literals.

using namespace std::chrono_literals;
auto day = 24h;
day.count(); // == 24
std::chrono::duration_cast<std::chrono::minutes>(day).count(); // ==1440

**********************************************************************************************************

***********************************************************************************************************
***********************************************************************************************************

									C++ 14 new library features :


**********************************************************************************************************
**********************************************************************************************************

1, [[deprecated]] attribute

- C++ 14 introduces the [[deprecated]] attribute to indicate that unit (function,class,etc.)
  is discouraged and likely yield compilation warnings.
- If a reason is provided, it will be included in the warnings.

[[deprecated]]
void old_method();
[[deprecated("Use new_method instead")]]
void legacy_method()

**************************************************************************************************************

2, variable templates:

- C++ 14 allows variables to be templated.

  template<class T>
  constexpr T pi = T(3.141592);
  
  template<class T>
  constexpr T e = T(1.71828);
  
**************************************************************************************************************

3, Relaxing constraints on constexpr functions

- In C++ 11, constexpr function bodies could only contain a vary limited set of syntaxex, includding (but not limited to):
  typedef S, using S, and a single return statement.

- In C++ 14, the set of allowable syntaxes expands greatly to include the most common syntax such as if statements, multiple return s, loops, etc

  constexpr int factorial(int n) {
		if(n<=1) {
			return 1;
		} else {
			return n * factorial(n-1);
		}
  }
  factorial(5); // == 120
  
***************************************************************************************************************

4, decltype(auto)

- The decltype(auto) type-specifier also deduces a type like auto does.
-  However, it deduces return type while keeeping their references and cv-qualifiers, while auto will not.

const int x = 0;
auto x1 = x; // int
decltype(auto) x2 = x; // const int

int y = 0;
int& y1 = y;
auto y2 = y1; // int
decltype(auto) y3 = y1;  // int&

int&& z = 0;
auto z1 = std::move(z);  // int
decltype(auto) z2 = std::move(z); // int&&

// Note:Especially useful for generic code!!
// Return type is 'int'
auto f(const int& i) {
return i;
}


//Return type is 'const int&'.
decltype(auto) g(const int&i) {
return i;
}

int x = 123;
static_assert(std::is_same<const int&,decltype(f(x))>::value == 0);
static_assert(std::is_same<int,decltype(f(x))>::value == 1);
static_assert(std::is_same<cont int&,decltype(g(x))>::value == 1);


***************************************************************************************************************

5, Return type deduction

- Using an auto return type in C++ 14, the compiler will attempt to deduce the type for you.
- With lambdas, you can now deduce its return type using auto, which makes returning a deduced reference or rvalue reference possible.

  // Deduce return type as 'int'
  auto f(int i) {
	return i;
  }
  
  template<typename T>
  auto& f(T& t)
  {
     return t;
  }
  
  //Returns a reference to a deduced type.
  auto g = [](auto& x) -> auto& { return f(x); };
  int y = 123;
  int&z = g(y); // reference to 'y'
  
***********************************************************************************************************************


6, lambda capture initializers

- This allows creating lambda captures initialized with arbitrary expressions.
- The name given to the captured value does not need to be related to any variables in the enclosing scopes and introduces a new name inside the lambda body.
- the initializing expression is evaluated when the lambda is created (not when it is invoked).

int factory(int i) { return i*10; }
auto f = [ x = factory(2)] { return x; };  // returns 20

auto generator = [ x = 0 ] () mutable {
	//this would not compile without mutable as we are modifying x on each call
	return x++;
};

auto a = generator(); // ==0
auto b = generator(); // ==1
auto c = generator(); // ==2

- Because it is now possible to move (or forward) values into a lambda that could previously be only captured by copy or reference we can now capture move-only types in a lamdba by value.
- Note that in the below example the p in the capture-list of task2 on the left-hand-side of = is a new variable private to the lambda body and does not refer to the original p.

  auto p = std::make_unique<int>(1);
  
  auto task1 = [=] {*p=5;} // ERROR std::unique_ptr cannot be copied
  // vs
  auto task2 = [ p = std::move(p}] {*p=5; }; // OK: p is move constructed into the closure object.
  // the original p is empty after task2 is created.

- Using this reference-captures can have different names than the referenced variable

  auto x = 1;
  auto f = [&r = x, x = x*10] {
   ++r;
   return r+x;
  };
  
  f(); // sets x to 2 and returns 12
  
 ******************************************************************************************************************************
  
7, Generic lambda expressions

- C++ 14 now allows the auto type-specifier in the parameter list, enabling polymorphic lambdas.

auto identity = [](auto x) { return x; };
int three = identity(3); // == 3
std::string foo = identity("foo"); // =="foo"

*****************************************************************************************************************************

8, Binary literals:

- Binary literals provide a convenient way to represent a base-2 number. It is possible to separate digits with '.

0b110 // == 6
0b1111'1111 // == 255


****************************************************************************************************************************

****************************************************************************************************************************
****************************************************************************************************************************

										C++ 17 new library features:

****************************************************************************************************************************
****************************************************************************************************************************

1, string conversion to/from numbers

- Convert integrals and floats to a string or vice-versa.
- Conversions are non-throwing, do not allocate, and are more secure than the equivalesnts from the C standard library.

- Users are responsible for allocating enough storage required for std::to_chars, or the function will fail by setting 
  the error code object in its return value.
  
- These functions allow you to optionally pass a base (default to base-10) or a format specifier for floating type input.
(01) std::to_chars returns a (non-const) char pointer which is one-past-the-end of the string that the function wrote to inside the given buffer,and an error code object.
(02) std::from_chars returns a const char pointer which on success is equal to the end pointer passed to the function, and an error code object.

- Both error code objects returned from these functions are equal to the default-initialized error code object on success.

- Convert the number 123 to a std::string:

  const int n = 123 
  
  // can use any container, string, array, etc.
  std::string str;
  str.resize(3);  // hold enough storage for each digit of 'n'
  
  const auto [ptr,ec ] = std::to_chars(str.data(),str.data()+str.size(),n);
  
  if(ec == std::errc{}) 
  { std::cout << str << std::endl; } // 123
  else { /* handle failure */ }
  
- convert from std::string with value "123" to an integer

  const std::string str{"123";
  int n;

  const auto [ ptr,ec ] = std::from_chars(str.data(),str.data()+str.size(),n);

 if(ec == std::errc{}) { std::cout << n << std::endl; } // 123
 else
 { /* handle failure */}


********************************************************************************************************************************

2, not_fn 

- Utility function that returns the negation of the result of the given function 

const std::ostream_iterator<int> ostream_it{std::cout," "};
const auto is_even = [](const auto n) { return n%2 == 0; }
std::vector<int> v{0,1,2,3,4};

// Print all even numbers.
std::copy_if(std::cbegin(v),std::cend(v),ostream_it,is_even); // 0 2 4
// print all odd numbers
std::copy_if(std::cbegin(v),std::cend(v),ostream_it,not_fn(is_even)); // 1 3 

*******************************************************************************************************************************

3, GCD and LCM

Greatest common divisor (GCD) and least common multiple(LCM)

const int p = 9;
const int q = 3;

std::gcd(p,q); // == 3
std::lcm(p,q); // == 9

*****************************************************************************************************************************

4, Prefix sum algorithms

- Support for prefix sums (both inclusive and exclusive scans) along with transformations.

const std::array<int,3> a {1,2,3};

std::inclusive_scan(std::cbegin(a),std::cend(a), std::ostream_iterator<int>{std::cout, " '},std::plus<>{});  // 1,3,6
std::exclusive_scan(std::cbegin(a),std::cend(a),std::ostream_itertor<int>{std::cout, " "),std::plus<>{}); // 0 1 3

const auto times_ten = [](const auto n) { return n*10; };

std::transform_inclusive_scan(std::begin(a),std::cend(a),std::ostream_iterator<int>{ std::cout, " "}, std::plus<>{},times_ten);   // 10 30 60
std::transform_exclusive_scan(std::cbegin(a),std::cend(a),std::ostream_iterator<int> { std::cout, " "}, std::plus<>{},times_ten);  // 0 10 30

******************************************************************************************************************************


5, std::reduce

- Fold over a given range of elements.
- Conceptually similar to std::accumulate,but std::reduce will perform the fold in parallel.
- Due to the fold being done in parallel,if you specify a binary operation, it is required to be associative and cummutative.
- A given binary operation also should not change any element or invalidate any iterators within the given range.

- The default binary operation in std::plus with an initial value of 0.

  const std::array<int,3> a{1,2,3};
  std::reduce(std::cbegin(a),std::cend(a));  // == 6
  // using a custom binary op:
  std::reduce(std::cbegin(a),std::cend(a),1,std::multiplies<>{}); // == 6
  
  Additionally you can specify transformations for reducers:
  
  std::transform_reduce(std::cbegin(a), std::cend(a), 0 , std::plus<>{}, times_ten); // ==60
  
  const std::array<int,3> b{ 1,2,3 };
  const auto product_times_ten = [](const auto a,const auto b) { return a*b*10 };
  
  std::transfrom_reduce(std::cbegin(a),std::cend(a),std::cbegin(b),0,std::plus<>{},product_times_ten); // == 140
  
********************************************************************************************************************************
  
  
6, clamp :

- Clamp given value between a lower and upper bound.

std::clamp(42,-1,1);  // == 1
std::clamp(-42,-2,1);  // == -1
std::clamp(0,-1,1); // == 0

// 'std::clamp' also accepts a custom comparator
std::clamp(0,-1,1,std::less<>{}); // == 0

*****************************************************************************************************************************

7, sample:

Samples n elements in the given sequence (without replacement) where every element has an equal chance of being selected.

const std::string ALLOWED_CHARS = "abcdefghijklmnopqrstuvwxyzABCEDEFGHIJKLMNOPQRST..Z0..9";
std::string guid;
// sample 5 characters from ALLOWED_CHARS
std::sample(ALLOWED_CHARS.begin(),ALLOWED_CHARS.end(),std::back_iterator(guid),5,std::mt19937{ std::random_device{}() });
std::cout << guid;  // e.g. G1fW2

***************************************************************************************************************************

8, parallel algorithms

- Many of the STL algorithms, such as the copy, find and sort methods, started to support the parallel execution policies:
  seq, par and par_unseq which translate to "sequentially","parallel" and "parallel unsequenced".
  
  std::vector<int> longVector;
  //find element using parallel execution policy.
  auto result1 = std::find(std::exeuction::par,std::begin(longVector),std::end(longVector),2);
  //Sort elements using sequential execution policy.
  auto result2 = std::sort(std::execution::seq,std::begin(longVector),std::end(longVector));
  
************************************************************************************************************************

9, Splicing for maps and sets

- Moving nodes and merging containers without the overhead of expensive copies,movies, or heap allocations/dealloctions.

- Moving elements from one map to another:

  std::map<int,string> src{{1,"one"},{2,"two"},{3,"buckle my shoe"}};
  std::map<int,string> dst{{3, "three"}};
  
  dst.insert(src.extract(src.find(1)));  // Cheap remove and insert of {1,"one"} from 'src' to 'dst'
  dst.insert(src.extract(2)); // cheap remove and insert of { 2, "two"} from 'src' to 'dst'.
  // dst = {{1,"one"},{2,"two"},{3,"three"}};

- Inserting an entire set:

  std::set<int> src {1,3,5};
  std::set<int> dst {2,4,5};
  dst.merge(src);
  // src == {5}
  // dst == { 1,2,3,4,5}
  
- Inserting elements which outlive the container
  
  auto elementFactory() {
	std::set<...> s;
	s.emplace(...);
	return s.extract(s.begin());
  }
  s2.insert(elementFactory());
  
- Changine the key of a map element:
  std::map<int,string> m {{1,"one",{2,"two"},{3,"three"}};
  auto e = m.extract(2);
  e.key() = 4;
  m.insert(std::move(e)); 
  // mm == {{ 1,"one"},{3,"three"},{4,"two"}} 
  
*****************************************************************************************************************************

10, byte

- The new std::byte type provides a standard way of representing data as a byte.
- Benefits of using std::byte over char or unsigned char is that it is not a character type, and is also not an arithmetic type;
  while the only operator overloads available are bitware operations.

  std::byte a{0};
  std::byte b{0xFF};
  int i = std::to_integer<int>(b); // 0xFF
  std::byte c = a & b;
  int j = std::to_integer<int>(c); // 0

- Note that std::byte is simply an enum, and braced initialization of enums become possible thanks to direct-list-initialization of enums.

*******************************************************************************************************************************

11, std::filesystem

- The new std::filesystem library provides a standard way to manipulate files, directories, and paths in a filesystem.

- Here, a big file is copied to a temporary path if there is available space: 
 
   const auto bigFilePath {"bigFileToCopy"};
   if(std::filesystem::exists(bigFilePath)) {
	const auto bigFileSize {std::filesystem::file_size(bigFilePath)};
	std::filesystem::path tmpPath{"\tmp"}
	if(std::filesystem::space(tmpPath).available > bigFileSize) {
		std::filesystem::create_directory(tmpPath.append("example"));
		std::filesystem::copy_file(bigFilePath,tmpPath.append("newfile"));
	}
   }
  
********************************************************************************************************************************

12, std::apply 

- Invoke a callable object with a tuple of arguments.

  auto add = [](int x,int y) {
	return x+y;
  }
  std::apply(add,std::make_tuple(1,2)); 
  
*******************************************************************************************************************************

13, std::invoked

- invoke a callable object with parameters.
- Examples of callable objects are std::function or lambdas; 
- objects that can be called similarly to a regular function.

template<typename Callable>
class Proxy {
  Callable c_;
  
public:
  Proxy(Callable _c) : _c{std::move(c)} {}
  
  template<typename... Args>
  decltype(auto) operator()(Args&&... args){
  {
	//...
	return std::invoke(c_,std::forward<Args>(args)...);
  }
};

const auto add=[](int x,int y) { return x+y };
Proxy p{add};
p(1,2)

*****************************************************************************************************************************

14, std::string_view
- A non-owning reference to a string.
- Useful for providing an abstraction on top of strings(e.g. for parsing).

//Regular strings.
std::string_view cppstr{"foo"};
//Wide strings.
std::wstring_view wcstr_v{L"baz"};
//Character arrays.
char array[3]={'b','a','r'};
std::string_view array_v(array,std::size(array));

std::string str("  trim me"};
std::string_view v{str};
v.remove_prefix(Std::min(v.find_first_not_of(" "),v.size()));
str; // == "  trim me"
v; // == "trim me"

*****************************************************************************************************************************

15, std::any

- A type-safe container for single value of any type.

  std::any x{5};
  x.has_value(); // == true
  std::any_cast<int>(x) // == 5
  std::any_cast<int&>(x) = 10
  std::any_cast<int>(x) // == 10 
  
***************************************************************************************************************************
  
16, optional

- The class template optional manages an optional contained value, i.e., a value that may or may not be present.
- A common use case for optional is the return value of a function that may fail.

std::optional<std::string> create(bool b) {
  if(b) {
    return "GodZilla";
  } else {
   return {};
  }
}

create(false).value_or("empty"); // == "empty"
create(true).value();  // == "Godzilla"
// optional-returning factory functions are usable as conditions of while and if
if(auto str = create(true)) {
// ...
}

**********************************************************************************************************************************
  
  
****************************************************************************************************************************
****************************************************************************************************************************

C++ 17 new language features :

****************************************************************************************************************************
****************************************************************************************************************************

1, Class template argument deduction 

- Class template argument deduction (CTAD) allows the compiler to deduce template arguments from constructor arguments.

  std::vector v{1,2,3};  // deduces std::vector<int>
  
  std::mutex mtx;
  auto lck  = std::lock_guard{ mtx }; // deduces to std::lock_guard<std::mutex>

  auto p = new std::pair {1.0,2.0 }; // deduces to std::pair<double,double>

- For user-defined types, deduction guides can be used to guide the compiler how to deduce template arguments if applicable.

  template<typename T>
  struct container {
	container(T t) {}
  template<typename Iter>
  container(Iter beg,Iter end);
  };
  
  // deduction guide
  template<typename Iter>
  container(Iter b,Iter e) -> container<typename std::iterator_traits<Iter>::value_type>;
  
  container a{ 7 }; // OK: deduces container<int>
  
  std::vector<double> v{1.0,2.0,3.0};
  auto b = container{ v.begin(),v.end() }; // OK: deduce container<double>
  
  container c{5,6};  // Error: std::iterator_traits<int>::value_type is not a type.
  
  
  ***********************************************************************************************************************************
  
2, __has_include :

- __has_include(operand) operator may be used in #if and #elif expressions to check whether a header or source file (operand ) is avaiable
  for inclusion or not.

- One use case of this would be using two libraries that work the same way, using the backup/experimental one if the preferred one is not found on the system
  #ifdef __has_include
  # if __has_include(<optional>)
  # 	include <optional>
  #     define have_optional 1
  # elif __has_include(<experimental/optional>)
  # 	include<experimental/optional>
  #     define have_optional 1
  #     define experimental_optional
  # else
  # 	define have_optional 0
  # endif
  #endif 
  
- It can also be used to include headers existing under different names or locations on various platforms, without knowing which platform the program is running on,
  OpenGL headers are a good example for this which are located in OpenGL \ directory on macOS and GL\ on other platforms.

  #ifdef __has_include
  #if __has_include(<OpenGL/gl.h>)
  # 	include <OpenGL/gl.h>
  #  	include <OpenGL/glu.h>
  #elif __has_include(<GL/gl.h>)
  #	  	include<GL/gl.h>
  #		include<GL/glu.h>
  #else
  # 	error No suitable OpenGL headers found.
  # endif
  #endif
  
************************************************************************************************************************************************  
  
[[fallthrough]], [[nodiscard]], [[maybe_unused]] attributes:

[[fallthrough]] indicates to the compiler that falling through in a switch statement is intended behaviour.
This attribute may only be used in a switch statement, and must be placed before the next case/default label.

switch(n) {
case 1:
// ...
[[fallthrough]];
case 2:
// ..
break;
case 3:
// ...
[[fallthrough]];
default:
// ...
}

[[nodiscard]] issues a warning when either a function or class has this attribute and its return value is discarded.

[[nodiscard]] bool do_something() {
return is_success; // true for success, false for failure
}

do_something(); // warning: ignoring return value of bool do_something declared with attribute 'nodiscard'

// Only issues a warning when error_info is returned by value:
struct[[nodiscard]] error_info {
// ...
};

error_info do_something() {
error_info e1;
//....
return e1;
}

do_something();  // warning: ignoring returned value of type 'error_info', 
                 // declared with attribute 'nodiscard'

[[maybe_unused]] indicates to the compiler that a variable or parameter might be unused and is intended.

void my_callback(std::string msg,[[maybe_unused]] bool error) {
// Don;e car if 'msg' is an error message, just log it.
log(msg);
}

********************************************************************************************************************************				 
  
4, Direct list initialization of enums.

- Enums can now be initilaized using braced syntax.

enum byte : unsigned char {};
byte b {0}; // OK
byte c {-1}; // ERROR
byte d = byte{1}; // OK
byte e = byte{256}; // ERROR  

********************************************************************************************************************************
 
 5, UTF-8 character literals
 
 - A character literal that begins with u8 is a character literal of type char.
 - The value of a UTF-8 character literal is equal to its ISO 10646 code point value.
 
   char x = u8'x'; 
   
 ******************************************************************************************************************************

 6, constexpr if

- Write code that is instantiated depending on a compile-time condition.

template<typename T>
constexpr bool isIntegral() {
	if constexpr(std::is_integral<T>::value) {
		return true;
	} else {
	return false;
	}
}


static_assert(isIntegral<int>() == true);
static_assert(isIntegral<char>() == true);
static_assert(isIntegral<double>() == false);

struct S{}
static_assert(isIntegral<S>() == false);


**********************************************************************************************************************************

7, Selection statements with initializer:

- New versions of the if and switch statments which simplify common code patterns and help users keeep scopes tight.

  {
	std::lock_guard<std::mutex> lk(mx);
	if(v.empty()) v.push_back(val);
  }
  // vs
  if(std::lock_guard<std::mutex> lk(mx); v.empty()) {
	v.push_back(val);
  }
  
  Foo gadget(args);
  switch(auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
  }
  // vs
  switch(Foo gadget(args); auto s = gadget.status()){
	case OK: gadget.zip(); break;
	case Bad: throw BadFoo(s.message());
 }
 
 *******************************************************************************************************************************
  
8, Structure bindings

- A proposal for de-structuring intialilzation, that would allow writing auto [x,y,z] = expr; 
  where the type of expr was a tuple-like object,whose elements would be bound to the variables x, y, and z (which this construct declares).

- Tuple like objects include std::tuple, std::pair, std::array and aggregate structures.

  using Coordinate = std::pair<int,int>
  Coordinate origin() 
  {
	return Coordinate{0,0};
  }  

  const auto [x,y] = origin();
  x; // == 0
  y; // == 0
  
  std::unordered_map<std::string,int> mapping {
  {"a",1},
  {"b",2},
  {"c",3}
  };
  
  //Destructure by reference
  for(const auto& [key, value]: mapping) {
    // Do something with key and value
  }
  
**************************************************************************************************************************

 9, Nested namespaces:
 
 - Using the namespace resolution operator to create nested namespace definitions.
 
   namespace  A {
   namespace B {
   namespace C {
	 int i;
   }
   }
   }
   
   The code above can be written like this:
   namespace A::B::C {
	int i;
   }
   
   
*************************************************************************************************************************

10, inline variables

- The inline specifier can be applied to variables as well as functions.
- A variable declared inline has the same semantics as a function declared inline.


//Disassembly example using compiler explorer.
struct S { int x; };
inline S x1 = S{321}; 

S x2 = S{123};

- It can also be used to declare and deine a static member variable, such that it does not need to be initalized in the source file.

struct S {
	S() : id{count++} {}
	~S() { count--; }
	int id;
	static inline int count{0};  // declare and initialize count to 0 within the class.
};

***********************************************************************************************************************

11, Lambda capture this by value

- Capturing this in a lambda's environment was previously reference-only.
- An example of where this is problematic is asynchronous code using callbacks that require an object to be available, potentially past its lifetime.
- *this will now make a copy of the current object, while this continues to capture by reference

struct MyObj {
	int val {123};
	auto getValueCopy() {
		return [*this] { return value; };
	}
    auto getValueRef() {
	    return [this] { return value; };
	}
};

MyObj mo;
auto valueCopy = mo.getValueCopy();
auto valueRef = mo.getValueRef();
mo.value = 321
valueCopy();  // 123
valueRef();  // 321 

************************************************************************************************************************

12, constexpr lambda

- Compile time lambdas using constexpr

auto identity = [](int x) constexpr { return n; };
static_assert(identity(123) == 123);

constexpr auto add = [](int x,int y) {
auto L = [=] { return x; };
auto R = [=] { return y; };
return [=] { return L() + R(); };
}

static_assert(add(1,2)() == 3);

constexpr int addOne(int n) {
return [n] { return n+1; }(); 
}

static_assert(addOne(1) == 2);

**********************************************************************************************************************

13, New rules for auto deduction from braced-init-list

- Changes to auot deduction when used with the uniform initialization syntax. 
- Previouly, auto x{3}; deduces a std::initializer_list<int>, which now deduces to int.

auto x1{1,2,3}; // error: not a single element
auto x2 = {1,2,3}; // x2 is std::initializer_list<int>
auto x3{3}; // x3 is int
auto x4{3.0}; // x4 is double. 

***********************************************************************************************************************

14, Folding expressions

-  A fold expression performs a fold of a template parameter pack over a binary operator. 

(01) An expression of the form (... op e) or (e op ...), where op is a fold operator and e is an unexpanded parameter 
     pack , are called unary folds.
(02) An expression of the form (e1 op ... op e2), where op are fold-operators, is called a binary fold.
     Either e1 or e2 is an unexpanded paramter pack, but not both.
	 
template<typename.. Args>
bool logicalAnd(Args... args) {
	//Binary folding.
     return(true && ... && args);
}
bool b = tue;
bool&b2 = b;
logicalAnd(b,b2,true); // == true

template<typename... Args>
auto sum(Args... args) {
    // Unary folding
	return(... + args);
}
sum(1.0,2.0f,3); // == 6.0 

*************************************************************************************************************************

15, Declaring non-type template parameters with auto

- Following the deduction rules of auto, while representing the non-type template parameter list of allowable type[*],
  template arguments can be deduced from the types of its arguments:
  
  template<auto... seq>
  struct my_integer_sequence {
	// Implements here ...
  };

  //Explicitly pass type 'int' as template argument.
  auto seq = std::integer_sequence<int,0,1,2>();
  // Type is deduced to be 'int'
  auto seq2 = my_integer_sequence<0,1,2>();
  
- For example, you cannot use a double as template parameter type, which also makes this an invalid deduction using auto.

**************************************************************************************************************************

**********************************************************************************************************************
**********************************************************************************************************************

											C++ 20 new library features:

**********************************************************************************************************************
**********************************************************************************************************************

1, to_array

- Converts the given array/"array-like" object to a std::array.

  std::to_array("foo");   // returns 'std::array<char,4>'
  std::to_array<int>({1,2,3});  // returns 'std::array<int,3>'
  
  int a[]={1,2,3};
  std::to_array(a); // returns 'std::array<int,3>'

********************************************************************************************************************** 
 
2, midpoint

-  Calculate the midpoint of two integers safely (without overflow).

std::midpoint(1,3); // == 2

********************************************************************************************************************

3, bit_cast 

- A safer way to reinterpret an object from one type to another.

float f = 123.0;
int i = bit_cast<int>(f); 

************************************************************************************************************************

4, check if associative container has element

- Associative containers suchs a sets and maps have a contains member function, which can be used instead of the "find and check end of iterator" idiom.

std::map<int, char> map {{1,'a'},{2,'b'}};
map.contains(2); // true
map.contains(123); // false

std::set<int> set{1,2,3};
set.contains(2); // true

************************************************************************************************************************

5, starts_with and ends_with on strings

- Strings (and string views) now have the starts_with and ends_with member functions to check if a string starts or ends with the given string.

std::string str="foobar";
str.starts_with("foo"); // true
str.ends_with("baz""); // false

***************************************************************************************************************************

6, make_shared supports arrays

  auto p = std::make_shared<int[]>(5); // pointer to int[5]
  // OR
  auto p = std::make_shared<int[5]>(); // pointer to int[5]
  
  
**************************************************************************************************************************

7, is_constant_evaluated

- predicate function which is truthy when it is called in a compile-time context.

  constexpr bool is_compile_time() {
	return std::is_constant_evaluated();
  }
  
  constexpr bool a = is_compile_time(); // true
  bool b = is_compile_time(); // false
  
***********************************************************************************************************************


8, Math constants

- Mathematical constants including PI, Euler's number, etc. defined in the <numbers> header.

std::numbers::pi; // 3.14159
std::numbers::e; // 2.71828

*********************************************************************************************************************

9, Bit operations:

- C++ 20 provides a new <bit> header which provides some bit operations including popcount.

std::popcount(ou); // 0
std::popcount(1u); // 1
std::popcount(0b1111'0000u); // 4

*******************************************************************************************************************

10, span

- A span is a view (i.e.non-owning) of a container providing bounds-checked access to a contiguous group of elements.
- Sinces views do not own their elements they are cheap to construct and copy -- a simplified way to think about views is 
  they are holding references to their data.
- As opposed to maintaining a pointer/iterator and length field, a span wraps both of those up in a single object. 

- Spans can be dynamically-sized or fixed-sized. Fixed-sized spans benefit from bounds-checking.
- Span doesn't propogate const so to construct a read-only span use std::span<const T>.

- Example: using a dynamically-sized span to print integers from various containers.

void print_ints(std::span<const int> ints> {
	for(const auto n : ints) {
		std::cout << n << std::endl;
    }
}

print_ints(std::vector{1,2,3});
print_ints(std::array<int,5>{1,2,3,4,5});

int a[10]={0};
print_ints(a);
//etc

- Example: a statically-sized span will fail to compile for containers that don't match the extent of the span.

void print_three_ints(std::span<const int,3> ints){
	for(const auto n : ints) {
	   std::cout << n << std::endl;
	}
}

print_three_ints(std::vector{ 1,2,3 }); // Error
print_three_ints(std::array<int,5>{ 1,2,3,4,5 }); // Error
int a[10] = {0};
print_three_ints(a); //Error

std::array<int,3> b = {1,2,3};
print_three_ints(b); // OK

// You can construct a span manually if required:
std::vector c{1,2,3};
print_three_ints(std::span<count int,3>{c.data(),3}); //Ok: set pointer and length field
print_three_ints(std::span<const int,3>{c.cbegin(),c.cend()}); // OK: use iterator pairs. 

*******************************************************************************************************************************

11, Synchronized buffered outpustream 

- Buffers output operations for the wrapped output stream ensuring synchronization(i.e., no interleaving of output).
  std::osyncstream{std::cout} << "The value of x is:" << x << std::endl; 

********************************************************************************************************************************
12, Concepts library 

- Concepts are also provided by the standard library for building more complicated concepts. 
  Some of these include:
  
  Core language concepts:
  * same_as - specifies two types are the same.
  * derived_from - specifies that a type is derived from another type.
  * convertiable_to - specifies that a type is implicitly convertible to another type.
  * common_with - specifies that two types share a common type.
  * integral - specifies that a type is an integral type.
  * default_constructible - specifies that an object of a type can be default-constructed.
  
  Comparsion concepts:
  * boolean - specifies that a type can be used in boolean contexts.
  * equality_comparable - specifies that operator== is an equivalence relation.
  
  Object concepts:
  * movable - specifies that an object of a type can be moved and swapped.
  * copyable - speciies that an object of a type can be copied, moved, and swapped.
  * semiregular - specifies that an object of a type can be copied, moved, swapped and default constructed.
  * regular - specifies that a type is regular, that is, it is both semiregular and equality_comparable.
  
  Callable concepts:
  * invocable - specifies that a callable type can be invoked with a given set of argument types.
  * predicate - specifies that a callable type is a Boolean predicate.
  
********************************************************************************************************************************



*******************************************************************************************************************************
*******************************************************************************************************************************

C++ 20 new language features :

*******************************************************************************************************************************
*******************************************************************************************************************************

1, constinit : The constinit specifier requires that a variable must be initialized at compile time.

const char* g() { return "dynamic initialization"; }
constexpr const char* f(bool p) { return p ? "constant initializer" :  g(); }

constinit const char* c = f(true);  //OK
constinit const char* d = f(false); //ERROR: 'g' is not constexpr, so 'd' cannot be evaluated at compile time 

*****************************************************************************************************************************

2, char8_t

Provides a standard type for representing UTF-8 strings.

char8_t utf8_str[] = u8"\u0123";

***************************************************************************************************************************

3, lambda capture of parameter pack

- Capture parameter packs by value.

template<tyename... Args>
auto f(Arg&&... args) {
	// BY VALUE:
	return [...args = std::forward<Args>(args)] {
	 // ...
	};
}

*************************************************************************************************************************

4, using enum

- Bring an enum's members into scope to improve readability. Before:

  enum class rgba_color_channel{ red, green, blue, alpha };
  
  std::string_view to_string(rgba_color_channel channel) 
  {
	switch(channel) {
		case rgba_color_channel::red:  return "red";
		case rgba_color_channel::green: return "green";
		case rgba_color_channel::blue: return "blue";
		case rgba_color_channel::return "alpha";
	}
  }

After:

  enum class rgba_color_channel { red, green, blue, alpha};
  std::string_view to_string(rgba_color_channel my_channel) {
  switch(my_channel) {
	using enum rgba_color_channel:
	case red:  return "red";
	case green:  return "green";
	case blue:  return "blue";
	case alpha: return "alpha";
	}
	}
	
***************************************************************************************************************

5, Immediate functions

- Similar to constexpr functions, but functions with a consteval specifier must produce a constant.
  These are called immediate functions.
  
  consteval int sqr(int n) {
	return n*n;
  }
  
  constexpr int r = sqr(100);   //OK
  int x = 100;
  int r2 = sqr(x);  // ERROR: the value of 'x' is not usable in a constant expression
                    // OK if 'sqr' were a 'constexpr' function
					
****************************************************************************************************************

6, explicit(bool) 

- Conditionally select at compile-time whether a constructor is made explicit or not.
- explicit(true) is the same as specifying explicit.

  struct foo {
  //Specify non-integral types (strings, floats, etc.) require explicit construction.
  template<typename T>
  explicit(!std::is_integral_v<T>) foo(T) {}
  };
  
  foo a = 123; // OK
  foo b =  "123";  // ERROR: explicit constructor is not a candidate (explicit specifier evaluates to true)
  foo c {"123"}; // OK
  
******************************************************************************************************************

7, constexpr virtual functions:

- Virtual functions can now be constexpr and evaluated at compile-time.
- constexpr virtual functions can override non-constexpr virtual functions and vice-versa.

struct X1 {
	virtual int f() const = 0;
};

struct X2: public X1 {
	constexpr virtual int f() const { return 2; }
};

struct X3: public X2 {
	virtual int f() const { return 3; }
};

struct X4: public X3 {
	constexpr virtual int f() const { return 4; }
};

constexpr X4 x4;
x4.f(); // == 4

****************************************************************************************************************

8, class types in non-type template parameters.

- Classes can now be used in non-type template parameters.
- Objects passed in as template arguments have the type const T, where T is the type of the object, and has static storage duration.

struct foo {
	foo() = default;
	constexpr foo(int) {}
};

template<foo f>
auto get_foo() {
	return f;
}

get_foo(); // uses implicit constructor
get_foo<foo{123}>();

*************************************************************************************************************

9, Deprecate implicit capture of this

- Implicitly capturing this in lambda capture using [=] is now deprecated; prefer capturing explicitly using [=,this] or [=,*this].

  struct int_value {
	int n = 0;
	auto getter_fn() {
		//BAD:
		//return [=]() { return n; };
		
		//GOOD:
		return [=, *this]() { return n; };
	}
  };
  
****************************************************************************************************************

10, [[likely]] and [[unlikely]] attributes.

- Provides a hint to the optimier that the labelled statement has a high probability of being executed.
  
  switch(n) {
  case 1:
  //...
  break;
  [[likely]] case 2: // n == 2 is considered to be arbitrarily more
  //...              // likely than any other value of n
  break;
  }
  
- If one of the likely/unlikely attributes appears after the right parenthesis of an if-statment, it indicates that the
  branch is likely/unlikely to have its substatement(body) executed.

  int random = get_random_number_between_x_and_y(0,3);
  if(random > 0) [[likely]] {
	//body of if statements
	//...
  }
  
- It can also be applied to the substatement (body) of an iteration statement
  while(unlikely_truthy_condition)[[unlikely]] {
  // body of while statement
  //..
  }
  
*******************************************************************************************************************++++++++++++++  

11, Range-based for loop with initializer

- This feature simplifies common code patterns, helps keep scopes tight, and offers an elegant solution to a common lifetime problem.

  for(auto v = std::vector{1,2,3}; auto& e : v) {
	std::cout << e;
  }
  // prints "123"
  
**********************************************************************************************************************************
  
12, Template syntax for lambdas

- Use familiar template syntax in lambda expressions.

auto f=[]<typename T>(std::vector<T> v) {
//. ..
} 
// prints "123"

***********************************************************************************************************************************

13, Designeted initializers:

- C-style designed initializer syntax.
- Any member fields that are not explicitly listed in the designated initalizer list are
  default-initialized.
  
struct A {
  int x;
  int y;
  int z = 123;
};

A a{.x=1,.z=2};  // a.x == 1, a.y == 0, a.z == 2

*********************************************************************************************************************************

14, Concepts 

- Concepts are named compile time predicates which constrain types. They take the following form:

  template<template-parameter-list>
  concept concept-name = constraint-expression;
  
  - where constraint-expression evalutes to a constexpr boolean.
  - constraints should model semantic requirements,such as whether a type is a numeric or hashable.
  - A compiler error results if a give type does not satify the concept it's bound by(i.e., constraint-expression returns fale).
  - Because constraints are evaluated at compile-time, they can provide more meaningful error messages and runtime safety.
  
  //'T' is not limited by any constraints.
  template<typename T>
  concept always_satified = true;
  // Limit 'T' to integrals.
  template<typename T>
  concept integral = std::is_integral<T>
  // Limit 'T' to both the 'integral' constraint and signedness.
  template<typename T.
  concept signed_integral = integral<T> && std::is_signed_v<T>;
  // Limit 'T' to both the 'integral' constraint and the negation of the signed_integral constraint
  template<typename T>
  concept unsigned_integral = integral<T> && !signed_integral<T>; 
  
  There are a variety of syntactic forms for enforcing concepts:
  
  // Forms for function parameters:
  // 'T' is a constrained type template parameter.
  template<my_concept T>
  void f(T v)
  
  // 'T' is a constrained type template parameter
  template<typename T>
	requires my_concept<T>
  void f(T v);
  
  // 'T' is a constrained type template parameter.
  template<typename T>
  void f(T v) requires my_concept<T>;
  
  // 'v' is a constrained deduced parameter.
  void f(my_concept auto v);
  
  // 'v' is a constrained non-type template parameter.
  template<my_concept auto v>
  void g()
  
  // Forms for auto-deduced varaibles:
  // 'foo' is a constrained auto-deduced value.
  my_concept auto foo = ...;
  
  // Forms for lambdas:
  // 'T' is a constrained type template parameter.
  auto f = []<my_concept T> (T v)
   // ...
  };
  
  // 'T' is a constrained type template parameter.
  auto f = []<typename T> requires my_concept<T> (T v) {
   // ...
  };
  
  // 'T' is a constrined type template parameter.
  auto f = []<typename T>(T v) requires my_concept<T> {
   // ...
  };
  
  // 'v' is a constrained deducted parameter
  auto f = [](my_concept auto v) {
    // ...
  };
  
  // 'v' is a constrained non-type template parameter.
  auto g = []<my_concept auto v>() {
  // ...
  }; 

   The requires keyword is used either to start a requires clause or a requires expression:

   template<typename T>
      requires my_concept<T>  // 'requires' clause
   void f(T);

   template<typename T>
   concept callable = requires (T f) { f(); }; // 'requires' expression
   
   template<typename T>
	requires requires (T x) { x+x; } // 'requires' clause and expression on same line
	T add(T a,T b) {
		return a + b;
	}
	
- Note that the parameter list in a requires expression is optional. Each requirement in a requires expression are one of the following. 
  
  
  
  
  
  




		






  




	
  
  
  
  
     






  
  

  


